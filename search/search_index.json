{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"IntelliGeo IntelliGeo is an open source QGIS plugin designed to bring the power of Large Language Models (LLMs) to the QGIS platform, making geospatial analysis more intuitive and efficient. The plugin is in development phase. We just released version 0.1.0 : IntelliGeo on QGIS Python Plugins Repository . To see the version history check our change log . Use of LLMs IntelliGeo leverages Large Language Models to automate and simplify geospatial workflows within QGIS. Designed for GIS professionals, IntelliGeo assists users by automatically generating analytical models in the form of PyQGIS scripts or workflows , enabling efficient operation of QGIS software. This AI-powered tool reduces the need for extensive manual coding or model creation, enhancing productivity and simplifying complex geospatial analyses. By seamlessly integrating with QGIS, IntelliGeo allows users to design and execute complex geoprocessing tasks with ease. Key Features Seamless integration with the QGIS environment LLM-powered automation of geoprocessing workflows Collaborative modeling between AI systems and human experts The Repository The IntelliGeo plugin is open-source, and its codebase is available on GitHub: IntelliGeo Repository This repository, maintained by the development team\u2014 Mahdi Farnaghi , Gustavo Garc\u00eda , and Zehao Lu \u2014in collaboration with the community, serves as the hub for the IntelliGeo project. Here, users can access the source code, report issues, and contribute to ongoing development. The code is licensed under the Apache 2.0 license , ensuring that the project remains open and accessible for future development and use. Funding through AiNed program The development of IntelliGeo is part of the project titled \"IntelliGeo: Laying the Groundwork for Integrating Large Language Models into GIS,\" funded by the Dutch Research Council ( NWO ) under the AiNed program. This program aims to promote the development and application of AI within Dutch businesses and governmental institutions. The project is managed by the Geo-Information Processing Department at the Faculty of ITC, University of Twente, and is carried out in collaboration with the Barcelona Supercomputing Center - Centro Nacional de Supercomputaci\u00f3n ( BSC ). Running from March 2023 to March 2024, the project seeks to revolutionize how geographical models are created by integrating advanced AI language models into open-source GIS tools. The initiative's main goal is to develop tools that enable AI and human experts to collaboratively design sophisticated models for a variety of applications, including flood risk detection, crop yield estimation, and environmental change prediction. Join Us We invite anyone passionate about open-source development, GIS, or AI to get involved! Whether you're interested in contributing code, improving documentation, or sharing ideas, your input is invaluable in shaping the future of IntelliGeo. If you\u2019d like to join us, reach out via email at IntelliGeo Email . Don\u2019t hesitate to open an issue if you encounter any bugs or have suggestions for improvements. Together, we can make geospatial analysis more powerful and accessible for everyone.","title":"Home"},{"location":"#intelligeo","text":"IntelliGeo is an open source QGIS plugin designed to bring the power of Large Language Models (LLMs) to the QGIS platform, making geospatial analysis more intuitive and efficient. The plugin is in development phase. We just released version 0.1.0 : IntelliGeo on QGIS Python Plugins Repository . To see the version history check our change log .","title":"IntelliGeo"},{"location":"#use-of-llms","text":"IntelliGeo leverages Large Language Models to automate and simplify geospatial workflows within QGIS. Designed for GIS professionals, IntelliGeo assists users by automatically generating analytical models in the form of PyQGIS scripts or workflows , enabling efficient operation of QGIS software. This AI-powered tool reduces the need for extensive manual coding or model creation, enhancing productivity and simplifying complex geospatial analyses. By seamlessly integrating with QGIS, IntelliGeo allows users to design and execute complex geoprocessing tasks with ease.","title":"Use of LLMs"},{"location":"#key-features","text":"Seamless integration with the QGIS environment LLM-powered automation of geoprocessing workflows Collaborative modeling between AI systems and human experts","title":"Key Features"},{"location":"#the-repository","text":"The IntelliGeo plugin is open-source, and its codebase is available on GitHub: IntelliGeo Repository This repository, maintained by the development team\u2014 Mahdi Farnaghi , Gustavo Garc\u00eda , and Zehao Lu \u2014in collaboration with the community, serves as the hub for the IntelliGeo project. Here, users can access the source code, report issues, and contribute to ongoing development. The code is licensed under the Apache 2.0 license , ensuring that the project remains open and accessible for future development and use.","title":"The Repository"},{"location":"#funding-through-ained-program","text":"The development of IntelliGeo is part of the project titled \"IntelliGeo: Laying the Groundwork for Integrating Large Language Models into GIS,\" funded by the Dutch Research Council ( NWO ) under the AiNed program. This program aims to promote the development and application of AI within Dutch businesses and governmental institutions. The project is managed by the Geo-Information Processing Department at the Faculty of ITC, University of Twente, and is carried out in collaboration with the Barcelona Supercomputing Center - Centro Nacional de Supercomputaci\u00f3n ( BSC ). Running from March 2023 to March 2024, the project seeks to revolutionize how geographical models are created by integrating advanced AI language models into open-source GIS tools. The initiative's main goal is to develop tools that enable AI and human experts to collaboratively design sophisticated models for a variety of applications, including flood risk detection, crop yield estimation, and environmental change prediction.","title":"Funding through AiNed program"},{"location":"#join-us","text":"We invite anyone passionate about open-source development, GIS, or AI to get involved! Whether you're interested in contributing code, improving documentation, or sharing ideas, your input is invaluable in shaping the future of IntelliGeo. If you\u2019d like to join us, reach out via email at IntelliGeo Email . Don\u2019t hesitate to open an issue if you encounter any bugs or have suggestions for improvements. Together, we can make geospatial analysis more powerful and accessible for everyone.","title":"Join Us"},{"location":"QuickStart/","text":"IntelliGeo Quick Start Welcome to the IntelliGeo Quick Start documentation! This guide showcases various examples and common use cases to help you understand how to use the plugin effectively for your geospatial tasks in QGIS. Whether you're a beginner or an advanced user, this document aims to provide clear and concise examples to get you started and expand your knowledge. Table of Contents Introduction Getting Started Example Use Cases Use Case 1: Automating Layer Styling Use Case 2: Batch Processing Use Case 3: Spatial Analysis Advanced Examples Troubleshooting and Tips Getting Started Before diving into the examples, ensure you have the following prerequisites: - QGIS Installed: Download and install the latest version of QGIS from QGIS.org. - Plugin Installation: Install intelliGeo from the QGIS Plugin Repository or your custom source. - API Key Ready: Make sure you have activated OpenAI's or Cohere's API key. - Sample Data:* Some examples use sample datasets. For a detailed guide, please refer to use.md . Once installed IntelliGeo, you should see the plugin's toolbar or menu added to your QGIS interface. You\u2019re now ready to follow along with the examples! Examples Use Cases Use Case 1: Generating Attribute Lists from a Vector Layer This example demonstrates how to generate a model that lists the attributes from a vector layer in the workspace by selecting the layer by name. Prompt : Generate a model to list the attributes from a vector layer in the workspace. Select the layer by name. Note : Replace the layer's name. Use Case 2: Producing Attribute Descriptions for a Vector Layer Prompt : Generate a model to produce a description for the attributes in a vector layer. The summary should include the attributes name, data type, number of NULL values, number of unique values. Select the layer by name. Note : Replace the layer's name. Use Case 3: Producing Statistics for Polygon Areas Prompt : I need to produce statistics for the area of the polygons in a layer loaded in the workspace. The statistics should include minimum, maximum, average, standard deviation, and number of features. Generate a model for this purpose. Select the layer by name. Note : Replace the layer's name. Advanced Examples Use Case 1: Calculating Buffers Around Features Prompt : Create a buffer area of 5000 meters and 40 segments around the features of a vector layer from the workspace. The layer should be selected by name. Note : Replace the layer's name Use Case 2: Random Points Prompt : Create a model that generates 1000 random points over the current map extent. The coordinate system is EPSG:28992. Use Case 3: Random Lines Prompt : Create a model that generates 1000 random lines over the current map extent. Each line should be 5000 meters longs. The coordinate system is EPSG:28992. Troubleshooting and Tips One of the most frequent issues users encounter when working with the plugin is the problem of \"hallucinated imports.\" This occurs when the script or model references imports or modules that do not exist in your QGIS environment or Python installation. To avoid this issue, yo may need to manually check the imported modules.","title":"IntelliGeo Quick Start"},{"location":"QuickStart/#intelligeo-quick-start","text":"Welcome to the IntelliGeo Quick Start documentation! This guide showcases various examples and common use cases to help you understand how to use the plugin effectively for your geospatial tasks in QGIS. Whether you're a beginner or an advanced user, this document aims to provide clear and concise examples to get you started and expand your knowledge.","title":"IntelliGeo Quick Start"},{"location":"QuickStart/#table-of-contents","text":"Introduction Getting Started Example Use Cases Use Case 1: Automating Layer Styling Use Case 2: Batch Processing Use Case 3: Spatial Analysis Advanced Examples Troubleshooting and Tips","title":"Table of Contents"},{"location":"QuickStart/#getting-started","text":"Before diving into the examples, ensure you have the following prerequisites: - QGIS Installed: Download and install the latest version of QGIS from QGIS.org. - Plugin Installation: Install intelliGeo from the QGIS Plugin Repository or your custom source. - API Key Ready: Make sure you have activated OpenAI's or Cohere's API key. - Sample Data:* Some examples use sample datasets. For a detailed guide, please refer to use.md . Once installed IntelliGeo, you should see the plugin's toolbar or menu added to your QGIS interface. You\u2019re now ready to follow along with the examples!","title":"Getting Started"},{"location":"QuickStart/#examples-use-cases","text":"","title":"Examples Use Cases"},{"location":"QuickStart/#use-case-1-generating-attribute-lists-from-a-vector-layer","text":"This example demonstrates how to generate a model that lists the attributes from a vector layer in the workspace by selecting the layer by name. Prompt : Generate a model to list the attributes from a vector layer in the workspace. Select the layer by name. Note : Replace the layer's name.","title":"Use Case 1: Generating Attribute Lists from a Vector Layer"},{"location":"QuickStart/#use-case-2-producing-attribute-descriptions-for-a-vector-layer","text":"Prompt : Generate a model to produce a description for the attributes in a vector layer. The summary should include the attributes name, data type, number of NULL values, number of unique values. Select the layer by name. Note : Replace the layer's name.","title":"Use Case 2: Producing Attribute Descriptions for a Vector Layer"},{"location":"QuickStart/#use-case-3-producing-statistics-for-polygon-areas","text":"Prompt : I need to produce statistics for the area of the polygons in a layer loaded in the workspace. The statistics should include minimum, maximum, average, standard deviation, and number of features. Generate a model for this purpose. Select the layer by name. Note : Replace the layer's name.","title":"Use Case 3: Producing Statistics for Polygon Areas"},{"location":"QuickStart/#advanced-examples","text":"","title":"Advanced Examples"},{"location":"QuickStart/#use-case-1-calculating-buffers-around-features","text":"Prompt : Create a buffer area of 5000 meters and 40 segments around the features of a vector layer from the workspace. The layer should be selected by name. Note : Replace the layer's name","title":"Use Case 1: Calculating Buffers Around Features"},{"location":"QuickStart/#use-case-2-random-points","text":"Prompt : Create a model that generates 1000 random points over the current map extent. The coordinate system is EPSG:28992.","title":"Use Case 2: Random Points"},{"location":"QuickStart/#use-case-3-random-lines","text":"Prompt : Create a model that generates 1000 random lines over the current map extent. Each line should be 5000 meters longs. The coordinate system is EPSG:28992.","title":"Use Case 3: Random Lines"},{"location":"QuickStart/#troubleshooting-and-tips","text":"One of the most frequent issues users encounter when working with the plugin is the problem of \"hallucinated imports.\" This occurs when the script or model references imports or modules that do not exist in your QGIS environment or Python installation. To avoid this issue, yo may need to manually check the imported modules.","title":"Troubleshooting and Tips"},{"location":"blogs/","text":"Blog Posts IntelliGeo at ICT Open 2025 IntelliGeo project was presented at NWO ICT.OPEN2025 which was held in Jaarbeurs Utrecht, 15 and 16 April 2025. The title of the poster by Gustavo and Mahdi was \"Fine-Tuning LLMs for Spatial Analysis and Modeling \u2013 An Initial Step\" . The abstract of the poster: Geospatial Information Science (GIScience) is a multidisciplinary field focused on developing methods for managing and analyzing geographic data, which are essential for understanding the spatial and temporal dynamics of natural and human-made processes. These analyses often require the creation of complex models within Geographic Information Systems (GIS). However, building such models typically demands specialized, modeling-specific knowledge, making them accessible primarily to GIS professionals. To address this barrier, we leverage the emerging capabilities of Large Language Models (LLMs) to democratize GIS modeling. As part of this effort, we developed and deployed IntelliGeo, a QGIS plugin that functions as an AI-powered modeling assistant. Since no current LLM is fine-tuned for spatial analysis and modeling, IntelliGeo enhances the capabilities of general-purpose LLMs through two mechanisms: Retrieval-Augmented Generation (RAG) to supply GIS-specific information to LLMs, and Few-Shot Learning to provide examples of prompts for generating geodata processing models along with their expected outputs. By iteratively capturing and refining user inputs, IntelliGeo not only simplifies modeling efforts but also contributes to building a dataset for fine-tuning LLMs for spatial analysis and modeling. In this poster, we describe the implementation of IntelliGeo, with special emphasis on the RAG and Few-Shot mechanisms. The poster presented at the conference: Keywords: LLM, GIS, Fine-tuning, QGIS plugin, RAG, Few-Shot Workshop at QGIS User Conference 2024 in Bratislava In a workshop at QGIS User Conference 2024, the IntelliGeo plugin was presented to the QGIS user community. We had a full room of interested people actively participating in the workshop. The workshop was started with an introduction to the IntelliGeo plugin and it's relation with AI/LLMs. Then the participants installed IntelliGeo, participated in a hands-on activity where they use the plugin to perform different GIS tasks. Finally, we had a very constructive feedback round where we collected amazing suggestion and collaboration opportunities. Some nice images from the workshop: IntelliGeo at ICT Open 2024 IntelliGeo project was presented at NWO ICT.OPEN2024 which was held in Jaarbeurs Utrecht, 10 and April 2024. The title of the presentation by Mahdi and Gustavo was \"Fine-Tuning LLMs for Spatial Analysis and Modeling \u2013 An Initial Step\" . The abstract of the talk: Geospatial Information Science (GIScience) combines Geography, Earth Science, and Computer Science to develop methods for handling geographical data such as satellite/UAV imagery and GPS observations, aiding in complex model building using Geographical Information System (GIS) platforms in sectors like climate change, food security, and health. The intersection of GIScience and recent advances in Large Language Models (LLMs) presents an opportunity to transform spatial analysis and modelling. However, the integration of LLMs into GIScience applications is hindered by the absence of fine-tuning datasets for spatial analysis and modelling tasks, thus a lack of task-specific LLMs in the GIScience domain. In response, we are working on a research project funded by the NWO Ai NED program to integrate general-purpose LLMs into QGIS, a widely used GIS platform. The main idea is to record expert user interactions with an out-of-the-box, general-purpose LLM. Since the LLM is not specialized for GIS tasks, users will need to interact with it iteratively to solve the GIS tasks. We hypothesize that recording such interactions will allow us to build a community-based specialized dataset to fine-tune LLMs for spatial analysis and modelling. This presentation will explain the main objectives of the project, its primary results, and the remaining steps. We will showcase our initial findings about the effective mechanisms to translate users\u2019 analytical descriptions into executable geoprocessing workflows in GIS. Primary results affirm the capacity of the proposed approach to democratize spatial analysis by embedding advanced Artificial Intelligence within GIS platforms. Keywords: LLM, GIS, Fine-tuning, Dataset, Spatial","title":"Blogs"},{"location":"blogs/#blog-posts","text":"","title":"Blog Posts"},{"location":"blogs/#intelligeo-at-ict-open-2025","text":"IntelliGeo project was presented at NWO ICT.OPEN2025 which was held in Jaarbeurs Utrecht, 15 and 16 April 2025. The title of the poster by Gustavo and Mahdi was \"Fine-Tuning LLMs for Spatial Analysis and Modeling \u2013 An Initial Step\" . The abstract of the poster: Geospatial Information Science (GIScience) is a multidisciplinary field focused on developing methods for managing and analyzing geographic data, which are essential for understanding the spatial and temporal dynamics of natural and human-made processes. These analyses often require the creation of complex models within Geographic Information Systems (GIS). However, building such models typically demands specialized, modeling-specific knowledge, making them accessible primarily to GIS professionals. To address this barrier, we leverage the emerging capabilities of Large Language Models (LLMs) to democratize GIS modeling. As part of this effort, we developed and deployed IntelliGeo, a QGIS plugin that functions as an AI-powered modeling assistant. Since no current LLM is fine-tuned for spatial analysis and modeling, IntelliGeo enhances the capabilities of general-purpose LLMs through two mechanisms: Retrieval-Augmented Generation (RAG) to supply GIS-specific information to LLMs, and Few-Shot Learning to provide examples of prompts for generating geodata processing models along with their expected outputs. By iteratively capturing and refining user inputs, IntelliGeo not only simplifies modeling efforts but also contributes to building a dataset for fine-tuning LLMs for spatial analysis and modeling. In this poster, we describe the implementation of IntelliGeo, with special emphasis on the RAG and Few-Shot mechanisms. The poster presented at the conference: Keywords: LLM, GIS, Fine-tuning, QGIS plugin, RAG, Few-Shot","title":"IntelliGeo at ICT Open 2025"},{"location":"blogs/#workshop-at-qgis-user-conference-2024-in-bratislava","text":"In a workshop at QGIS User Conference 2024, the IntelliGeo plugin was presented to the QGIS user community. We had a full room of interested people actively participating in the workshop. The workshop was started with an introduction to the IntelliGeo plugin and it's relation with AI/LLMs. Then the participants installed IntelliGeo, participated in a hands-on activity where they use the plugin to perform different GIS tasks. Finally, we had a very constructive feedback round where we collected amazing suggestion and collaboration opportunities. Some nice images from the workshop:","title":"Workshop at QGIS User Conference 2024 in Bratislava"},{"location":"blogs/#intelligeo-at-ict-open-2024","text":"IntelliGeo project was presented at NWO ICT.OPEN2024 which was held in Jaarbeurs Utrecht, 10 and April 2024. The title of the presentation by Mahdi and Gustavo was \"Fine-Tuning LLMs for Spatial Analysis and Modeling \u2013 An Initial Step\" . The abstract of the talk: Geospatial Information Science (GIScience) combines Geography, Earth Science, and Computer Science to develop methods for handling geographical data such as satellite/UAV imagery and GPS observations, aiding in complex model building using Geographical Information System (GIS) platforms in sectors like climate change, food security, and health. The intersection of GIScience and recent advances in Large Language Models (LLMs) presents an opportunity to transform spatial analysis and modelling. However, the integration of LLMs into GIScience applications is hindered by the absence of fine-tuning datasets for spatial analysis and modelling tasks, thus a lack of task-specific LLMs in the GIScience domain. In response, we are working on a research project funded by the NWO Ai NED program to integrate general-purpose LLMs into QGIS, a widely used GIS platform. The main idea is to record expert user interactions with an out-of-the-box, general-purpose LLM. Since the LLM is not specialized for GIS tasks, users will need to interact with it iteratively to solve the GIS tasks. We hypothesize that recording such interactions will allow us to build a community-based specialized dataset to fine-tune LLMs for spatial analysis and modelling. This presentation will explain the main objectives of the project, its primary results, and the remaining steps. We will showcase our initial findings about the effective mechanisms to translate users\u2019 analytical descriptions into executable geoprocessing workflows in GIS. Primary results affirm the capacity of the proposed approach to democratize spatial analysis by embedding advanced Artificial Intelligence within GIS platforms. Keywords: LLM, GIS, Fine-tuning, Dataset, Spatial","title":"IntelliGeo at ICT Open 2024"},{"location":"change/","text":"Changelog IntelliGeo v0.1.1 Fifth release New Features Cross-Platform Installation Enhancements : The installation process has been optimized for Linux, macOS, and Windows, providing a more seamless and reliable setup experience across all supported platforms. Bug Fixes Installation Process Fixes : Resolved various issues affecting installation. IntelliGeo v0.1.0 Fourth & Stable Release New Features Memory Support : IntelliGeo now includes short-term memory for the LLM agent, allowing you to update and modify previously generated workflows. Workflow Slection : Multiple interactions are generated, and selecting a workflow triggers its execution. Better Dependecy management : Dependencies are now installed automatically. IntelliGeo v0.0.3 - Third Release New Features Enhanced Interface : IntelliGeo now features an improved and more visually appealing chat interface. Toolbox Code Generation : IntelliGeo now supports generating toolbox codes, making it easier to streamline your development process. Next Plans Memory Support : IntelliGeo will include short-term memory capabilities in the next version, allowing you to enhance or fix generated code more effectively. IntelliGeo v0.0.2 - Second Release New Features Reflection Mechanism : IntelliGeo now attempts to debug problematic PyQGIS scripts and provide improved output when such scripts are generated. LLM Inference Threading : Previously, waiting for an LLM response would block the entire QGIS interface. IntelliGeo now runs LLM inference on a separate thread, allowing users to continue other operations while waiting for the response. Next Plans Chat Interface : We will be updating the current chat interface in IntelliGeo over the next few versions to enhance user experience and functionality. IntelliGeo v0.0.1 - First Release Sep 9, 2024 We are excited to announce the first release of IntelliGeo , a powerful QGIS plugin that integrates OpenAI's ChatGPT to automate and generate workflows for PyQGIS and graphical models. This is version v0.0.1, marking the initial step toward AI-driven geospatial workflow creation directly within QGIS. Key Features AI-Powered Workflow Generation : Leverage ChatGPT to automatically generate PyQGIS scripts and graphical models based on user input and queries. Seamless QGIS Integration : Work directly within QGIS to streamline geospatial tasks using AI-assisted workflow creation. Customizable Workflows : Generated workflows are fully customizable, allowing users to tailor the outputs for specific project needs. User-Friendly Interface : A simple and intuitive interface that lets users interact with the LLM engine and execute generated workflows efficiently. How to Install Download the IntelliGeo v0.0.1 ZIP file below this announcement. In QGIS, go to Plugins > Manage and Install Plugins > Install from ZIP , and select the downloaded file. Once installed, IntelliGeo will be available under the Plugins menu. What's Next This is an early version, and we\u2019re actively working on adding more features and improving the plugin\u2019s functionality. Future releases will include more llms, bug fixes, and expanded capabilities. Feedback & Contributions Your feedback is essential to improving IntelliGeo! Feel free to open an issue if you encounter any bugs, have suggestions, or would like to contribute.","title":"Change Log"},{"location":"change/#changelog","text":"","title":"Changelog"},{"location":"change/#intelligeo-v011-fifth-release","text":"","title":"IntelliGeo v0.1.1 Fifth release"},{"location":"change/#new-features","text":"Cross-Platform Installation Enhancements : The installation process has been optimized for Linux, macOS, and Windows, providing a more seamless and reliable setup experience across all supported platforms.","title":"New Features"},{"location":"change/#bug-fixes","text":"Installation Process Fixes : Resolved various issues affecting installation.","title":"Bug Fixes"},{"location":"change/#intelligeo-v010-fourth-stable-release","text":"","title":"IntelliGeo v0.1.0 Fourth &amp; Stable Release"},{"location":"change/#new-features_1","text":"Memory Support : IntelliGeo now includes short-term memory for the LLM agent, allowing you to update and modify previously generated workflows. Workflow Slection : Multiple interactions are generated, and selecting a workflow triggers its execution. Better Dependecy management : Dependencies are now installed automatically.","title":"New Features"},{"location":"change/#intelligeo-v003-third-release","text":"","title":"IntelliGeo v0.0.3 - Third Release"},{"location":"change/#new-features_2","text":"Enhanced Interface : IntelliGeo now features an improved and more visually appealing chat interface. Toolbox Code Generation : IntelliGeo now supports generating toolbox codes, making it easier to streamline your development process.","title":"New Features"},{"location":"change/#next-plans","text":"Memory Support : IntelliGeo will include short-term memory capabilities in the next version, allowing you to enhance or fix generated code more effectively.","title":"Next Plans"},{"location":"change/#intelligeo-v002-second-release","text":"","title":"IntelliGeo v0.0.2 - Second Release"},{"location":"change/#new-features_3","text":"Reflection Mechanism : IntelliGeo now attempts to debug problematic PyQGIS scripts and provide improved output when such scripts are generated. LLM Inference Threading : Previously, waiting for an LLM response would block the entire QGIS interface. IntelliGeo now runs LLM inference on a separate thread, allowing users to continue other operations while waiting for the response.","title":"New Features"},{"location":"change/#next-plans_1","text":"Chat Interface : We will be updating the current chat interface in IntelliGeo over the next few versions to enhance user experience and functionality.","title":"Next Plans"},{"location":"change/#intelligeo-v001-first-release","text":"Sep 9, 2024 We are excited to announce the first release of IntelliGeo , a powerful QGIS plugin that integrates OpenAI's ChatGPT to automate and generate workflows for PyQGIS and graphical models. This is version v0.0.1, marking the initial step toward AI-driven geospatial workflow creation directly within QGIS.","title":"IntelliGeo v0.0.1 - First Release"},{"location":"change/#key-features","text":"AI-Powered Workflow Generation : Leverage ChatGPT to automatically generate PyQGIS scripts and graphical models based on user input and queries. Seamless QGIS Integration : Work directly within QGIS to streamline geospatial tasks using AI-assisted workflow creation. Customizable Workflows : Generated workflows are fully customizable, allowing users to tailor the outputs for specific project needs. User-Friendly Interface : A simple and intuitive interface that lets users interact with the LLM engine and execute generated workflows efficiently.","title":"Key Features"},{"location":"change/#how-to-install","text":"Download the IntelliGeo v0.0.1 ZIP file below this announcement. In QGIS, go to Plugins > Manage and Install Plugins > Install from ZIP , and select the downloaded file. Once installed, IntelliGeo will be available under the Plugins menu.","title":"How to Install"},{"location":"change/#whats-next","text":"This is an early version, and we\u2019re actively working on adding more features and improving the plugin\u2019s functionality. Future releases will include more llms, bug fixes, and expanded capabilities.","title":"What's Next"},{"location":"change/#feedback-contributions","text":"Your feedback is essential to improving IntelliGeo! Feel free to open an issue if you encounter any bugs, have suggestions, or would like to contribute.","title":"Feedback &amp; Contributions"},{"location":"development/","text":"Development Instructions Running the Project Locally Clone the project into the QGIS plugins folder: To locate the folder, open QGIS and navigate to Settings > User profiles > Open Active Profile Folder . The plugins folder is located within the python/plugin folder. Set up the QGISDIR environment variable: Point the QGISDIR variable to the plugins folder. Create a Python environment: Set up and activate a Python environment in your project through the terminal. Modify the interface using QT Designer: Open the QT Designer installed by QGIS. Open the intelli_geo_dockwidget_base.ui file. Make modifications. Save the file. Compile the interface using pb_tool : Install pb_tool using pip: pip install pb-tool Install pyqt5ac using pip: pip install pyqt5ac On Linux, due to a known issue , installing Qt via pip may cause incompatibility with QT5. The solution is to install the following packages: sudo apt-get install python3-pyqt5 sudo apt-get install qtcreator pyqt5-dev-tools sudo apt-get install qttools5-dev-tools Verify if pb_tool.exe is located in the Python environment\u2019s scripts folder. Navigate to the intelli_geo module folder in the terminal and run: pbt compile Activate the plugin in QGIS: In QGIS, go to Plugins > Manage and Install Plugins . Select the \"Installed\" tab and check the box next to IntelliGeo. Close the plugins manager, and the IntelliGeo menu should appear in the Plugins menu. Contributing to the Project - External Contributors If you want to contribute to the IntelliGeo project but are not part of the team, follow these steps to fork the repository: Go to the IntelliGeo repository on GitHub. In the top-right corner, click Fork . For more information, see the GitHub Forking Guide . Clone the forked repository to your local machine, make changes, and commit them to your forked repository. To propose your changes to the main IntelliGeo repository, create a pull request: On your forked repository, click New pull request . GitHub will check for merge conflicts, but only the IntelliGeo team can approve or merge changes. Contributing to the Project - Team Members Pull the latest version of the main branch: git checkout main git pull origin main Create a new branch: git checkout -b <new_branch_name> Make your changes. Stage your changes: git add . Commit your changes: git commit -m \"Detailed message about the changes\" Push the branch for review: git push origin <new_branch_name> On GitHub, you will see the new branch. Use the Compare & pull request button to initiate a pull request with the main branch. In the Open a pull request window, add a description, select reviewers, and click Create pull request . The team will review the changes. If approved, they will merge the branch into the main branch using the Merge pull request button. Optionally, delete the old branch after merging. Packaging & Release The recommended way to package the plugin is by using pb_tool . You can find its documentation at the provided link. Before releasing, you need a ZIP file containing the packaged plugin code. Ensure the version number is properly set in metadata.txt Ensure that all necessary files are listed in the pbtool.config file under the [files] section. This includes: python_files for Python source code, main_dialog and compiled_ui_files for UI files. If you have updated any icons and need to compile them, run: pb_tool compile Next, create the ZIP package by running: pb_tool zip The generated ZIP file will be located in the zip_build folder. To release you should go to the plugin hub , log in, click on Add Verion and upload the zip file, remember to add proper changlog. Tips for development for plugin I found that reading environmental variable in plugin source code won't work. a work around way is that you can create a txt file named intelligeo_var.txt in your ~Document/QGIS_IntelliGeo/ folder, to store the encironmental variables and read those variables using utils.getIntelligeoEnvVar function. If you want to make sure all interactions from the team will be marked as fromdev = True in backend database, put the following line in the intelligeo_var.txt file. intelliGeo_fromdev = true The other important thing is debuging for the pluging is not easy, if you want to show a variable's value, use utils.show_variable_popup . Documentation The project's documentation is managed using MkDocs . Documentation is generated from the .md files in the docs folder, with settings configured in mkdocs.yml at the root of the repository. Testing the Documentation Locally To test the documentation locally, follow these steps: Install the required packages by running: pip install -U mkdocs mkdocs-material mkdocs-bootswatch mkdocs-ultralytics-plugin Navigate to the IntelliGeo folder, then start the local server with: mkdocs serve This will start a local server and make your site available at http://127.0.0.1:8000/ . Open this URL in your browser to view the documentation. Building the Site The build process is automated via GitHub Actions. You can review the workflow in .github/workflows/deploy.yml . To check the workflow prior to pushing it on GitHub, we use act . Development Roadmap Known Issues & Discussions IntelliGeo team have noticed that Cohere language models are not very stable and likely to crash when they update backend services. In that sense, we suggest you to use openai when there are problems with Cohere. If you meet any bug or issue with using our plugin, you can go to our issue list on github repository and check if there are any existing issues, if not you can post a new one. We are a very small team so we can not update the plugin very fast, we will try to react as fast as we can.","title":"Development"},{"location":"development/#development-instructions","text":"","title":"Development Instructions"},{"location":"development/#running-the-project-locally","text":"Clone the project into the QGIS plugins folder: To locate the folder, open QGIS and navigate to Settings > User profiles > Open Active Profile Folder . The plugins folder is located within the python/plugin folder. Set up the QGISDIR environment variable: Point the QGISDIR variable to the plugins folder. Create a Python environment: Set up and activate a Python environment in your project through the terminal. Modify the interface using QT Designer: Open the QT Designer installed by QGIS. Open the intelli_geo_dockwidget_base.ui file. Make modifications. Save the file. Compile the interface using pb_tool : Install pb_tool using pip: pip install pb-tool Install pyqt5ac using pip: pip install pyqt5ac On Linux, due to a known issue , installing Qt via pip may cause incompatibility with QT5. The solution is to install the following packages: sudo apt-get install python3-pyqt5 sudo apt-get install qtcreator pyqt5-dev-tools sudo apt-get install qttools5-dev-tools Verify if pb_tool.exe is located in the Python environment\u2019s scripts folder. Navigate to the intelli_geo module folder in the terminal and run: pbt compile Activate the plugin in QGIS: In QGIS, go to Plugins > Manage and Install Plugins . Select the \"Installed\" tab and check the box next to IntelliGeo. Close the plugins manager, and the IntelliGeo menu should appear in the Plugins menu.","title":"Running the Project Locally"},{"location":"development/#contributing-to-the-project-external-contributors","text":"If you want to contribute to the IntelliGeo project but are not part of the team, follow these steps to fork the repository: Go to the IntelliGeo repository on GitHub. In the top-right corner, click Fork . For more information, see the GitHub Forking Guide . Clone the forked repository to your local machine, make changes, and commit them to your forked repository. To propose your changes to the main IntelliGeo repository, create a pull request: On your forked repository, click New pull request . GitHub will check for merge conflicts, but only the IntelliGeo team can approve or merge changes.","title":"Contributing to the Project - External Contributors"},{"location":"development/#contributing-to-the-project-team-members","text":"Pull the latest version of the main branch: git checkout main git pull origin main Create a new branch: git checkout -b <new_branch_name> Make your changes. Stage your changes: git add . Commit your changes: git commit -m \"Detailed message about the changes\" Push the branch for review: git push origin <new_branch_name> On GitHub, you will see the new branch. Use the Compare & pull request button to initiate a pull request with the main branch. In the Open a pull request window, add a description, select reviewers, and click Create pull request . The team will review the changes. If approved, they will merge the branch into the main branch using the Merge pull request button. Optionally, delete the old branch after merging.","title":"Contributing to the Project - Team Members"},{"location":"development/#packaging-release","text":"The recommended way to package the plugin is by using pb_tool . You can find its documentation at the provided link. Before releasing, you need a ZIP file containing the packaged plugin code. Ensure the version number is properly set in metadata.txt Ensure that all necessary files are listed in the pbtool.config file under the [files] section. This includes: python_files for Python source code, main_dialog and compiled_ui_files for UI files. If you have updated any icons and need to compile them, run: pb_tool compile Next, create the ZIP package by running: pb_tool zip The generated ZIP file will be located in the zip_build folder. To release you should go to the plugin hub , log in, click on Add Verion and upload the zip file, remember to add proper changlog.","title":"Packaging &amp; Release"},{"location":"development/#tips-for-development-for-plugin","text":"I found that reading environmental variable in plugin source code won't work. a work around way is that you can create a txt file named intelligeo_var.txt in your ~Document/QGIS_IntelliGeo/ folder, to store the encironmental variables and read those variables using utils.getIntelligeoEnvVar function. If you want to make sure all interactions from the team will be marked as fromdev = True in backend database, put the following line in the intelligeo_var.txt file. intelliGeo_fromdev = true The other important thing is debuging for the pluging is not easy, if you want to show a variable's value, use utils.show_variable_popup .","title":"Tips for development for plugin"},{"location":"development/#documentation","text":"The project's documentation is managed using MkDocs . Documentation is generated from the .md files in the docs folder, with settings configured in mkdocs.yml at the root of the repository.","title":"Documentation"},{"location":"development/#testing-the-documentation-locally","text":"To test the documentation locally, follow these steps: Install the required packages by running: pip install -U mkdocs mkdocs-material mkdocs-bootswatch mkdocs-ultralytics-plugin Navigate to the IntelliGeo folder, then start the local server with: mkdocs serve This will start a local server and make your site available at http://127.0.0.1:8000/ . Open this URL in your browser to view the documentation.","title":"Testing the Documentation Locally"},{"location":"development/#building-the-site","text":"The build process is automated via GitHub Actions. You can review the workflow in .github/workflows/deploy.yml . To check the workflow prior to pushing it on GitHub, we use act .","title":"Building the Site"},{"location":"development/#development-roadmap","text":"","title":"Development Roadmap"},{"location":"development/#known-issues-discussions","text":"IntelliGeo team have noticed that Cohere language models are not very stable and likely to crash when they update backend services. In that sense, we suggest you to use openai when there are problems with Cohere. If you meet any bug or issue with using our plugin, you can go to our issue list on github repository and check if there are any existing issues, if not you can post a new one. We are a very small team so we can not update the plugin very fast, we will try to react as fast as we can.","title":"Known Issues &amp; Discussions"},{"location":"installation/","text":"Installation and API Keys To be able to use IntelliGeo, you need to first install it in your QGIS software and then obtain an API key to use large language models. Section 1 of this page explains how you can install the library and section 2 walk you through obtaining API keys for large language models from OpenAI, Cohere and Groq and registering them in QGIS. 1. Installation There are two ways to install the IntelliGeo plugin: via the QGIS plugin hub or by installing it from the source. Install from plugin hub In QGIS, click on plugins -> Manage and install Plugins , In the search bar, type \"IntelliGeo\", locate the plugin and click on Install Experimental Plugin . Install from source Visit the IntelliGeo GitHub repository and download the latest release of the plugin as a ZIP file. Install via QGIS Plugin Manager: Open QGIS. Go to Plugins > Manage and Install Plugins . Click the Install from ZIP button. Browse to the location where you downloaded the IntelliGeo ZIP file and select it. Click Install Plugin . Activate the Plugin: Go to Plugins > Manage and Install Plugins . Find IntelliGeo in the list and check the box next to it to activate the plugin. Dependency [!NOTE] In some cases, you may need to install the dependencies manually. We are working on fixing this issue, but some users may still need to take this step. Linux & MacOS For Linux or macOS, use pip to install the Python dependencies listed in the requirements.txt file. Navigate to IntelliGeo folder, and run the following command, pip install -r requirements.txt Windows For Windows, ou can use the OSGeo4W shell, which comes with QGIS. First, open the OSGeo4W shell (found in the QGIS installation folder). Then, use the pip command to install packages listed in the requirements.txt file., just as you would in a regular Python environment, by running pip install package_name . This will ensure that the packages are installed in the environment QGIS uses. For a step-by-step guide, you can watch this video tutorial that demonstrates the process in detail. 2. Obtaining API Key for IntelliGeo To use the IntelliGeo plugin, you need access to a large language model (LLM) via an API. Currently, we support both OpenAI and Cohere . Based on our experience, OpenAI models perform better but require a paid plan. Cohere, while offering free access to their API, delivers slightly lower performance compared to OpenAI. OpenAI Guide Step 1: Sign Up Register for ChatGPT at OpenAI Signup . You can sign up using an email address or an existing Google, Microsoft, or Apple account. Step 2: Open the Dashboard Once registered, navigate to the OpenAI dashboard at OpenAI Dashboard to access your API keys. Step 3: Generate an API Key To create a new API key, go to the API Keys section, click on + Create new secret key , and optionally name it in the pop-up. Once you click 'Create secret key', a unique alphanumeric API key will be generated. Be sure to store this key securely. This API key works universally for all OpenAI models; you don\u2019t need separate keys for each model. Step 4: Use the API Key in IntelliGeo Copy your API key and input it when starting a new conversation within IntelliGeo. The key will be saved only in your local database; the IntelliGeo backend does not store or access your API key. Cohere Guide Step 1: Sign Up Sign up for Cohere at Cohere Signup . You can register using your email address or an existing Google or GitHub account. Step 2: Access the Dashboard Once logged in, go to the API Keys section to manage your API keys. Step 3: Create an API Key To generate an API key, go to API Keys , then click + New Trial key , optionally name it, and click 'Create secret key' to generate your unique API key. Make sure to store the key securely. The Cohere API key works for all models, so you don\u2019t need to create multiple keys. Step 4: Use the API Key in IntelliGeo Copy your Cohere API key and input it when starting a new conversation in IntelliGeo. As with OpenAI, your key is stored locally and never accessed by IntelliGeo\u2019s backend. Once your API key is set up, you can start using the IntelliGeo plugin. Click on the IntelliGeo icon to open the chat interface. From there, you can chat and use the AI-powered geo-workflow features. Groq Guide Step 1: Sign Up Sign up for Groq at Groq Signup . You can register using your email address or an existing Google or GitHub account. Step 2: Access the Dashboard Once logged in, go to the API Keys section to manage your API keys. Step 3: Create an API Key To generate an API key, go to API Keys , then click Create API key , optionally name it, and click 'Submit' to generate your unique API key. Make sure to store the key securely. The Groq API key works for all models, so you don\u2019t need to create multiple keys. Step 4: Use the API Key in IntelliGeo Copy your Groq API key and input it when starting a new conversation in IntelliGeo. As with OpenAI, your key is stored locally and never accessed by IntelliGeo\u2019s backend. Once your API key is set up, you can start using the IntelliGeo plugin. Click on the IntelliGeo icon to open the chat interface. From there, you can chat and use the AI-powered geo-workflow features. DeepSeek Guide Step 1: Sign Up Sign up for deepseek at DeepSeek Signup . You can register using your email address or an existing Google account. Step 2: Access the Dashboard Once logged in, go to the API Keys section to manage your API keys. Step 3: Create an API Key To generate an API key, go to API Keys , then click Create New API key , optionally name it, and click 'Create API key' to generate your unique API key. Make sure to store the key securely. The Deepseek API key works for all models, so you don't need to create multiple keys. Step 4: Use the API Key in IntelliGeo Copy your DeepSeek API key and input it when starting a new conversation in IntelliGeo. As with OpenAI, your key is stored locally and never accessed by IntelliGeo's backend. Once your API key is set up, you can start using the IntelliGeo plugin. Click on the IntelliGeo icon to open the chat interface. From there, you can chat and use the AI-powered geo-workflow features.","title":"Installation"},{"location":"installation/#installation-and-api-keys","text":"To be able to use IntelliGeo, you need to first install it in your QGIS software and then obtain an API key to use large language models. Section 1 of this page explains how you can install the library and section 2 walk you through obtaining API keys for large language models from OpenAI, Cohere and Groq and registering them in QGIS.","title":"Installation and API Keys"},{"location":"installation/#1-installation","text":"There are two ways to install the IntelliGeo plugin: via the QGIS plugin hub or by installing it from the source.","title":"1. Installation"},{"location":"installation/#install-from-plugin-hub","text":"In QGIS, click on plugins -> Manage and install Plugins , In the search bar, type \"IntelliGeo\", locate the plugin and click on Install Experimental Plugin .","title":"Install from plugin hub"},{"location":"installation/#install-from-source","text":"Visit the IntelliGeo GitHub repository and download the latest release of the plugin as a ZIP file. Install via QGIS Plugin Manager: Open QGIS. Go to Plugins > Manage and Install Plugins . Click the Install from ZIP button. Browse to the location where you downloaded the IntelliGeo ZIP file and select it. Click Install Plugin . Activate the Plugin: Go to Plugins > Manage and Install Plugins . Find IntelliGeo in the list and check the box next to it to activate the plugin.","title":"Install from source"},{"location":"installation/#dependency","text":"[!NOTE] In some cases, you may need to install the dependencies manually. We are working on fixing this issue, but some users may still need to take this step.","title":"Dependency"},{"location":"installation/#linux-macos","text":"For Linux or macOS, use pip to install the Python dependencies listed in the requirements.txt file. Navigate to IntelliGeo folder, and run the following command, pip install -r requirements.txt","title":"Linux &amp; MacOS"},{"location":"installation/#windows","text":"For Windows, ou can use the OSGeo4W shell, which comes with QGIS. First, open the OSGeo4W shell (found in the QGIS installation folder). Then, use the pip command to install packages listed in the requirements.txt file., just as you would in a regular Python environment, by running pip install package_name . This will ensure that the packages are installed in the environment QGIS uses. For a step-by-step guide, you can watch this video tutorial that demonstrates the process in detail.","title":"Windows"},{"location":"installation/#2-obtaining-api-key-for-intelligeo","text":"To use the IntelliGeo plugin, you need access to a large language model (LLM) via an API. Currently, we support both OpenAI and Cohere . Based on our experience, OpenAI models perform better but require a paid plan. Cohere, while offering free access to their API, delivers slightly lower performance compared to OpenAI.","title":"2. Obtaining API Key for IntelliGeo"},{"location":"installation/#openai-guide","text":"","title":"OpenAI Guide"},{"location":"installation/#step-1-sign-up","text":"Register for ChatGPT at OpenAI Signup . You can sign up using an email address or an existing Google, Microsoft, or Apple account.","title":"Step 1: Sign Up"},{"location":"installation/#step-2-open-the-dashboard","text":"Once registered, navigate to the OpenAI dashboard at OpenAI Dashboard to access your API keys.","title":"Step 2: Open the Dashboard"},{"location":"installation/#step-3-generate-an-api-key","text":"To create a new API key, go to the API Keys section, click on + Create new secret key , and optionally name it in the pop-up. Once you click 'Create secret key', a unique alphanumeric API key will be generated. Be sure to store this key securely. This API key works universally for all OpenAI models; you don\u2019t need separate keys for each model.","title":"Step 3: Generate an API Key"},{"location":"installation/#step-4-use-the-api-key-in-intelligeo","text":"Copy your API key and input it when starting a new conversation within IntelliGeo. The key will be saved only in your local database; the IntelliGeo backend does not store or access your API key.","title":"Step 4: Use the API Key in IntelliGeo"},{"location":"installation/#cohere-guide","text":"","title":"Cohere Guide"},{"location":"installation/#step-1-sign-up_1","text":"Sign up for Cohere at Cohere Signup . You can register using your email address or an existing Google or GitHub account.","title":"Step 1: Sign Up"},{"location":"installation/#step-2-access-the-dashboard","text":"Once logged in, go to the API Keys section to manage your API keys.","title":"Step 2: Access the Dashboard"},{"location":"installation/#step-3-create-an-api-key","text":"To generate an API key, go to API Keys , then click + New Trial key , optionally name it, and click 'Create secret key' to generate your unique API key. Make sure to store the key securely. The Cohere API key works for all models, so you don\u2019t need to create multiple keys.","title":"Step 3: Create an API Key"},{"location":"installation/#step-4-use-the-api-key-in-intelligeo_1","text":"Copy your Cohere API key and input it when starting a new conversation in IntelliGeo. As with OpenAI, your key is stored locally and never accessed by IntelliGeo\u2019s backend. Once your API key is set up, you can start using the IntelliGeo plugin. Click on the IntelliGeo icon to open the chat interface. From there, you can chat and use the AI-powered geo-workflow features.","title":"Step 4: Use the API Key in IntelliGeo"},{"location":"installation/#groq-guide","text":"","title":"Groq Guide"},{"location":"installation/#step-1-sign-up_2","text":"Sign up for Groq at Groq Signup . You can register using your email address or an existing Google or GitHub account.","title":"Step 1: Sign Up"},{"location":"installation/#step-2-access-the-dashboard_1","text":"Once logged in, go to the API Keys section to manage your API keys.","title":"Step 2: Access the Dashboard"},{"location":"installation/#step-3-create-an-api-key_1","text":"To generate an API key, go to API Keys , then click Create API key , optionally name it, and click 'Submit' to generate your unique API key. Make sure to store the key securely. The Groq API key works for all models, so you don\u2019t need to create multiple keys.","title":"Step 3: Create an API Key"},{"location":"installation/#step-4-use-the-api-key-in-intelligeo_2","text":"Copy your Groq API key and input it when starting a new conversation in IntelliGeo. As with OpenAI, your key is stored locally and never accessed by IntelliGeo\u2019s backend. Once your API key is set up, you can start using the IntelliGeo plugin. Click on the IntelliGeo icon to open the chat interface. From there, you can chat and use the AI-powered geo-workflow features.","title":"Step 4: Use the API Key in IntelliGeo"},{"location":"installation/#deepseek-guide","text":"","title":"DeepSeek Guide"},{"location":"installation/#step-1-sign-up_3","text":"Sign up for deepseek at DeepSeek Signup . You can register using your email address or an existing Google account.","title":"Step 1: Sign Up"},{"location":"installation/#step-2-access-the-dashboard_2","text":"Once logged in, go to the API Keys section to manage your API keys.","title":"Step 2: Access the Dashboard"},{"location":"installation/#step-3-create-an-api-key_2","text":"To generate an API key, go to API Keys , then click Create New API key , optionally name it, and click 'Create API key' to generate your unique API key. Make sure to store the key securely. The Deepseek API key works for all models, so you don't need to create multiple keys.","title":"Step 3: Create an API Key"},{"location":"installation/#step-4-use-the-api-key-in-intelligeo_3","text":"Copy your DeepSeek API key and input it when starting a new conversation in IntelliGeo. As with OpenAI, your key is stored locally and never accessed by IntelliGeo's backend. Once your API key is set up, you can start using the IntelliGeo plugin. Click on the IntelliGeo icon to open the chat interface. From there, you can chat and use the AI-powered geo-workflow features.","title":"Step 4: Use the API Key in IntelliGeo"},{"location":"team/","text":"Core Team The core team that is working on the project are listed below. We would like to highlight that we invite anyone who is interested to join the development team to get in touch with us through the project email address: IntelliGeo Email . Current team Gustavo G. Chapeton Gustavo is a Lecturer and Researcher at the Geo-Information Processing Department, Faculty ITC, University of Twente. His teaching and research are in the domains of systems engineering and geo-informatics. His role in this project is as a Research Engineer. His work in IntelliGeo includes system workflow, user interface, data preparation for training and testing, prompt engineering, and troubleshooting. Profile page Linkedin Mahdi Farnaghi Mahdi is an Assistant Professor at Geo-Information Processing Department Faculty ITC, University of Twente. His research is situated at the intersection of Artificial Intelligence and Geography, encompassing various areas of AI such as machine learning, deep learning, natural language processing, data mining, linked data/semantic web, and planning/scheduling. IntelliGeo was born out of discussions between Mahdi and Gustavo, with Mahdi serving as the Principal Investigator (PI) of the project. His focus includes conceptualizing the framework, leading the agentic design of IntelliGeo in relation to large language models (LLMs), and architecting the library\u2019s structure. Profile page Linkedin Past Contributors Zehao Lu Lu is a skilled developer and machine learning engineer with expertise in AI, natural language processing (NLP), and large language model (LLM) applications. His work on IntelliGeo focused on integrating LLMs to generate executable PyQGIS scripts and QGIS models, simplifying user workflows in QGIS. Lu has since transitioned to a new role at Wageningen University, where he continues to advance his career. We are grateful for his significant contributions to IntelliGeo and wish him continued success.","title":"Core team"},{"location":"team/#core-team","text":"The core team that is working on the project are listed below. We would like to highlight that we invite anyone who is interested to join the development team to get in touch with us through the project email address: IntelliGeo Email .","title":"Core Team"},{"location":"team/#current-team","text":"","title":"Current team"},{"location":"team/#gustavo-g-chapeton","text":"Gustavo is a Lecturer and Researcher at the Geo-Information Processing Department, Faculty ITC, University of Twente. His teaching and research are in the domains of systems engineering and geo-informatics. His role in this project is as a Research Engineer. His work in IntelliGeo includes system workflow, user interface, data preparation for training and testing, prompt engineering, and troubleshooting. Profile page Linkedin","title":"Gustavo G. Chapeton"},{"location":"team/#mahdi-farnaghi","text":"Mahdi is an Assistant Professor at Geo-Information Processing Department Faculty ITC, University of Twente. His research is situated at the intersection of Artificial Intelligence and Geography, encompassing various areas of AI such as machine learning, deep learning, natural language processing, data mining, linked data/semantic web, and planning/scheduling. IntelliGeo was born out of discussions between Mahdi and Gustavo, with Mahdi serving as the Principal Investigator (PI) of the project. His focus includes conceptualizing the framework, leading the agentic design of IntelliGeo in relation to large language models (LLMs), and architecting the library\u2019s structure. Profile page Linkedin","title":"Mahdi Farnaghi"},{"location":"team/#past-contributors","text":"","title":"Past Contributors"},{"location":"team/#zehao-lu","text":"Lu is a skilled developer and machine learning engineer with expertise in AI, natural language processing (NLP), and large language model (LLM) applications. His work on IntelliGeo focused on integrating LLMs to generate executable PyQGIS scripts and QGIS models, simplifying user workflows in QGIS. Lu has since transitioned to a new role at Wageningen University, where he continues to advance his career. We are grateful for his significant contributions to IntelliGeo and wish him continued success.","title":"Zehao Lu"},{"location":"tutorials/","text":"Tutorials QGIS User Conference 2025 This tutorial was prepared as part of the workshop \"AI-powered model building in QGIS,\" held at the QGIS UC25 . Requirements for this tutorial: QGIS >= 3.0.0 IntelliGeo plugin >= 0.1.0 Sample project About the data The sample project includes data from two data sources: Movebank and GADM . The GPS tracking data of European Freetailed bats (Tadarida teniotis) was produced by [O\u2019Mara et al., 2021], and is available under a Creative Commons license on the website Movebank . The data layer with administrative units (level 1) for Portugal and Spain was prepared using data available under a Creative Commons license at GADM . Plugin installation For detailed installation instructions, please refer to installation.md . Creating a new conversation Figure 1 illustrates the process to create a new conversation: Click on the new conversation icon Provide a name Provide a description Select the LLM to use as back-end Provide a valid API Key for the LLM Figure 1: Creating a new conversation. Requesting general information In this section, you will interact with IntelliGeo to request general information about QGIS , the plugin, and the data available at your working space. You are encouraged to experiment with the provided prompts. Step: 1 Prompt: What is QGIS? Expected output: Description of the QGIS software. Example output: QGIS (Quantum GIS) is a free and open-source Geographic Information System (GIS) that allows you to create, edit, visualize, analyze and publish geospatial information. It supports various formats and functionalities, including vector, raster, and database formats. QGIS is widely used for spatial analysis, data management, and map production. It also supports plugins to enhance its functionality and can be customized using the PyQGIS Python API. Step: 2 Prompt: What is a QGIS plugin? Expected output: Description of a plugin for QGIS. Example output: A QGIS plugin is a piece of software that adds new functionality or extends the capabilities of the QGIS application. Plugins can be developed by anyone using the Python programming language and the QGIS API (Application Programming Interface). They can be used for a variety of tasks, such as automating common tasks, customizing the user interface, performing complex spatial analyses, connecting to external databases, and much more. QGIS has a built-in Plugin Manager that allows users to install, update, and manage plugins directly within the application. Step: 3 Prompt: Where can I get information about QGIS plugins? Expected output: Information about QGIS Plugin Repository. Example output: You can find information about QGIS plugins in several places: QGIS Plugin Repository : This is the official repository where all approved QGIS plugins are listed. You can access it directly from your QGIS software by going to Plugins > Manage and Install Plugins. Here, you can search for plugins, read their descriptions, and install them. QGIS Documentation : The official QGIS documentation provides information about core plugins and how to use them. You can access it at https://docs.qgis.org . Plugin Documentation : Most plugins come with their own documentation that provides detailed information about their functionality and usage. This documentation is usually accessible from the plugin's page in the QGIS Plugin Repository. QGIS Community : The QGIS community is a great resource for information about plugins. You can ask questions and share experiences on the QGIS mailing list or on GIS Stack Exchange. Remember to always check the compatibility of the plugin with your QGIS version. Step: 4 Prompt: Is IntelliGeo a QGIS plugin? Expected output: Confirmation that IntelliGeo is a QGIS plugin. Example output: Yes, IntelliGeo is a QGIS plugin designed to assist users with various GIS tasks within the QGIS environment. It provides guidance, troubleshooting advice, and support for creating processing workflows. Step: 5 Prompt: What can I do with IntelliGeo? Expected output: A list of tasks that IntelliGeo can support. Example output: With IntelliGeo, you can: Get step-by-step instructions for various GIS tasks in QGIS. Receive troubleshooting advice for common issues and errors. Get support in designing and executing project workflows. Learn about the latest updates on QGIS features and plugins. Generate processing workflows for the model designer by creating .model3 files. Get assistance in using PyQGIS for scripting and automating GIS tasks. Retrieve detailed information about your current QGIS project environment, including layer details and attributes. Remember, IntelliGeo is designed to provide concise, straightforward, and actionable information to help you efficiently use QGIS for your spatial analysis and GIS project needs. Processing with a single data layer In this section, you will generate scripts to process a single data layer. Step: 6 Prompt: Create a script to calculate the number of data points for each bat in the layer \"bats_data,\" which is already loaded in the workspace. Expected output: Script to calculate the number of points for each bat. Example output: Sure, here is a PyQGIS script that calculates the number of data points for each bat in the \"bats_data\" layer. # Import necessary modules from qgis.core import QgsProject # Get the project instance project = QgsProject.instance() # Get the \"bats_data\" layer layer = project.mapLayersByName('bats_data')[0] # Check if the layer is valid if not layer.isValid(): print(\"Layer failed to load!\") else: # Create a dictionary to store the count of data points for each bat bat_counts = {} # Iterate over each feature (data point) in the layer for feature in layer.getFeatures(): # Get the bat id from the feature's attributes bat_id = feature['bat_id'] # If the bat id is already in the dictionary, increment the count if bat_id in bat_counts: bat_counts[bat_id] += 1 # If the bat id is not in the dictionary, add it with a count of 1 else: bat_counts[bat_id] = 1 # Print the count of data points for each bat for bat, count in bat_counts.items(): print(f\"Bat {bat} has {count} data points.\") This script first gets the \"bats_data\" layer from the current QGIS project. It then iterates over each feature (data point) in the layer, getting the bat ID from the feature's attributes. The script keeps a count of the number of data points for each bat in a dictionary. Finally, it prints out the count of data points for each bat. Example execution: Bat Bat4_3D6001852B980 has 1466 data points. Bat Bat5_3D6001852B98C has 1397 data points. Bat Bat1_3D6001852B958 has 1265 data points. Bat Bat6_3D6001852B98E has 1435 data points. Bat Bat3_3D6001852B978 has 1568 data points. Bat Bat2_3D6001852B95D has 219 data points. Bat Bat8_3D6001852B9A7 has 900 data points. Bat Bat7_3D6001852B9A3 has 1623 data points. Step: 7 Prompt: Create a script that calculates basic statistics for the \"height\" attribute in the \"bats_data\" layer, which is already loaded in the workspace. The script should compute the following statistics: total number of points, minimum height, maximum height, average (mean) height, standard deviation of height. Expected output: Script to calculate basic statistics for the field \"height.\" Example output: # Import the required module from qgis.core import QgsVectorLayer, QgsFeatureRequest # Get the layer layer = QgsProject.instance().mapLayersByName('bats_data')[0] # Check if the layer is valid if not layer.isValid(): print(\"Layer failed to load!\") else: # Get the index of the 'height' field field_index = layer.fields().indexFromName('height') # Initialize variables to store statistics total_points = 0 min_height = float('inf') max_height = float('-inf') sum_height = 0 sum_squared_height = 0 # Iterate over each feature in the layer for feature in layer.getFeatures(): # Get the height value height = feature.attributes()[field_index] # Update statistics total_points += 1 min_height = min(min_height, height) max_height = max(max_height, height) sum_height += height sum_squared_height += height**2 # Calculate mean and standard deviation mean_height = sum_height / total_points std_dev_height = (sum_squared_height / total_points - mean_height**2)**0.5 # Print the statistics print(f\"Total number of points: {total_points}\") print(f\"Minimum height: {min_height}\") print(f\"Maximum height: {max_height}\") print(f\"Average (mean) height: {mean_height}\") print(f\"Standard deviation of height: {std_dev_height}\") Example execution: Total number of points: 9873 Minimum height: 4.0 Maximum height: 3150.0 Average (mean) height: 650.0176238225463 Standard deviation of height: 252.26758042089847 Step: 8 Prompt: Modify the latest produced script to calculate the statistics for each individual bat, using the \"bat_id\" field. Expected output: Script to calculate basic statistics per individual for the field \"height.\" Example output: # Import the required module from qgis.core import QgsVectorLayer, QgsFeatureRequest from collections import defaultdict # Get the layer layer = QgsProject.instance().mapLayersByName('bats_data')[0] # Check if the layer is valid if not layer.isValid(): print(\"Layer failed to load!\") else: # Get the index of the 'height' and 'bat_id' fields height_index = layer.fields().indexFromName('height') bat_id_index = layer.fields().indexFromName('bat_id') # Initialize a dictionary to store statistics for each bat bat_stats = defaultdict(lambda: {'total_points': 0, 'min_height': float('inf'), 'max_height': float('-inf'), 'sum_height': 0, 'sum_squared_height': 0}) # Iterate over each feature in the layer for feature in layer.getFeatures(): # Get the height and bat_id values height = feature.attributes()[height_index] bat_id = feature.attributes()[bat_id_index] # Update statistics for the current bat bat_stats[bat_id]['total_points'] += 1 bat_stats[bat_id]['min_height'] = min(bat_stats[bat_id]['min_height'], height) bat_stats[bat_id]['max_height'] = max(bat_stats[bat_id]['max_height'], height) bat_stats[bat_id]['sum_height'] += height bat_stats[bat_id]['sum_squared_height'] += height**2 # Calculate mean and standard deviation for each bat and print the statistics for bat_id, stats in bat_stats.items(): mean_height = stats['sum_height'] / stats['total_points'] std_dev_height = (stats['sum_squared_height'] / stats['total_points'] - mean_height**2)**0.5 print(f\"Bat ID: {bat_id}\") print(f\"Total number of points: {stats['total_points']}\") print(f\"Minimum height: {stats['min_height']}\") print(f\"Maximum height: {stats['max_height']}\") print(f\"Average (mean) height: {mean_height}\") print(f\"Standard deviation of height: {std_dev_height}\") print() Example execution: Bat ID: Bat4_3D6001852B980 Total number of points: 1466 Minimum height: 6.0 Maximum height: 1658.0 Average (mean) height: 721.6589358799454 Standard deviation of height: 275.40828363177724 Bat ID: Bat5_3D6001852B98C Total number of points: 1397 Minimum height: 166.0 Maximum height: 2704.0 Average (mean) height: 755.6406585540444 Standard deviation of height: 246.34593936186914 Bat ID: Bat1_3D6001852B958 Total number of points: 1265 Minimum height: 26.0 Maximum height: 3150.0 Average (mean) height: 668.7446640316206 Standard deviation of height: 279.81218789617225 Bat ID: Bat6_3D6001852B98E Total number of points: 1435 Minimum height: 4.0 Maximum height: 1228.0 Average (mean) height: 543.7602787456447 Standard deviation of height: 248.23846792712698 Bat ID: Bat3_3D6001852B978 Total number of points: 1568 Minimum height: 22.0 Maximum height: 2266.0 Average (mean) height: 673.4489795918367 Standard deviation of height: 270.03197552342056 Bat ID: Bat2_3D6001852B95D Total number of points: 219 Minimum height: 22.0 Maximum height: 1550.0 Average (mean) height: 616.3013698630137 Standard deviation of height: 198.86940839731218 Bat ID: Bat8_3D6001852B9A7 Total number of points: 900 Minimum height: 256.0 Maximum height: 1146.0 Average (mean) height: 604.9911111111111 Standard deviation of height: 106.70613815984397 Bat ID: Bat7_3D6001852B9A3 Total number of points: 1623 Minimum height: 70.0 Maximum height: 968.0 Average (mean) height: 580.6247689463955 Standard deviation of height: 194.04819050116532 Step: 9 Prompt: Create a script to generate a line vector layer from the existing \"bats_data\" layer, which is already loaded in the workspace. The script should create one line per bat, using the \"bat_id\" field to group individual bats. Ensure that the points for each bat are ordered chronologically based on the \"timestamp\" field before constructing the lines. Expected output: A script that groups the records per bat and creates line features from these groups. Example output: # Import necessary modules from qgis.PyQt.QtCore import QVariant from qgis.core import (QgsFeature, QgsField, QgsGeometry, QgsPoint, QgsVectorLayer, QgsProject) # Get the bats_data layer layer = QgsProject.instance().mapLayersByName('bats_data')[0] # Create a new memory layer for the lines line_layer = QgsVectorLayer('LineString', 'bat_paths', 'memory') # Add the necessary fields to the new layer pr = line_layer.dataProvider() pr.addAttributes([QgsField('bat_id', QVariant.String)]) line_layer.updateFields() # Create a dictionary to store the points for each bat bat_points = {} # Iterate over the features in the bats_data layer for feature in layer.getFeatures(): # Get the bat_id and timestamp for the current feature bat_id = feature['bat_id'] timestamp = feature['timestamp'] # Get the geometry of the current feature and convert it to a point geom = feature.geometry() point = QgsPoint(geom.asPoint()) # If the bat_id is not already in the dictionary, add it with the point and timestamp if bat_id not in bat_points: bat_points[bat_id] = [(timestamp, point)] # If the bat_id is already in the dictionary, append the point and timestamp to the list else: bat_points[bat_id].append((timestamp, point)) # Iterate over the bats in the dictionary for bat_id, points in bat_points.items(): # Sort the points by timestamp points.sort() # Create a new feature for the line layer feat = QgsFeature() # Set the bat_id field to the current bat_id feat.setAttributes([bat_id]) # Create a line geometry from the sorted points and set it for the feature line = QgsGeometry.fromPolyline([point for timestamp, point in points]) feat.setGeometry(line) # Add the feature to the line layer pr.addFeature(feat) # Update the extents of the line layer line_layer.updateExtents() # Add the line layer to the map QgsProject.instance().addMapLayer(line_layer) Example execution: Figure 2: Individual bats trajectories. Step: 10 Prompt: Create a script that generates a vector layer representing a regular grid of 0.05 degrees \u00d7 0.05 degrees cells covering the full extent of the \"bats_data\" layer, which is already loaded in the workspace. Then, aggregate the data from \"bats_data\" by counting the number of points that fall within each grid cell. Expected output: A script that produces a grid and aggregates the records from the \"bats_data\" layer. Example output: # Import necessary modules from qgis.core import QgsVectorLayer, QgsProcessing, QgsProcessingFeatureSourceDefinition from qgis.analysis import QgsNativeAlgorithms import processing # Initialize QGIS's processing framework QgsApplication.processingRegistry().addProvider(QgsNativeAlgorithms()) # Get the \"bats_data\" layer bats_data_layer = QgsProject.instance().mapLayersByName('bats_data')[0] # Define the grid size grid_size = 0.05 # Define the parameters for the \"Create grid\" algorithm grid_parameters = { 'TYPE': 2, # Rectangle (polygon) 'EXTENT': bats_data_layer.extent(), # Use the extent of the \"bats_data\" layer 'HSPACING': grid_size, # Horizontal spacing 'VSPACING': grid_size, # Vertical spacing 'CRS': bats_data_layer.crs(), # Coordinate reference system 'OUTPUT': 'memory:' # Output to memory } # Run the \"Create grid\" algorithm grid_result = processing.run('native:creategrid', grid_parameters) # Get the resulting grid layer grid_layer = grid_result['OUTPUT'] # Define the parameters for the \"Count points in polygon\" algorithm count_parameters = { 'POLYGONS': grid_layer, # Use the grid layer as the polygon layer 'POINTS': QgsProcessingFeatureSourceDefinition(bats_data_layer.id()), # Use the \"bats_data\" layer as the point layer 'OUTPUT': 'memory:' # Output to memory } # Run the \"Count points in polygon\" algorithm count_result = processing.run('native:countpointsinpolygon', count_parameters) # Get the resulting layer result_layer = count_result['OUTPUT'] # Add the resulting layer to the map QgsProject.instance().addMapLayer(result_layer) Example execution: Figure 3: Aggregated data over a grid. Processing with two data layers Step: 11 Prompt: Create a script to count the number of points from the \"bats_data\" layer that fall within each polygon of the \"Iberian_Peninsula_Level_1\" layer. Both layers are already loaded in the workspace. The script must produce a new in-memory vector layer containing the polygons from \"Iberian_Peninsula_Level_1\", with a field named \"COUNT\" that indicates the number of points contained within each polygon. Expected output: Script to calculate the number of records within each administrative division (level 1). Example output: # Import necessary modules from qgis.core import * # Define the names of the input layers point_layer_name = \"bats_data\" polygon_layer_name = \"Iberian_Peninsula_Level_1\" # Retrieve the layers from the current project point_layer = QgsProject.instance().mapLayersByName(point_layer_name)[0] polygon_layer = QgsProject.instance().mapLayersByName(polygon_layer_name)[0] # Create a new in-memory vector layer to store the results result_layer = QgsVectorLayer(\"Polygon?crs=epsg:4326\", \"result\", \"memory\") # Start editing the result layer result_layer.startEditing() # Add a new field to the result layer to store the count of points result_layer.dataProvider().addAttributes([QgsField(\"COUNT\", QVariant.Int)]) result_layer.updateFields() # Create a spatial index for the point layer to speed up the spatial query index = QgsSpatialIndex(point_layer.getFeatures()) # Iterate over each feature (i.e., polygon) in the polygon layer for polygon_feature in polygon_layer.getFeatures(): # Create a new feature for the result layer result_feature = QgsFeature(result_layer.fields()) # Copy the geometry from the polygon feature result_feature.setGeometry(polygon_feature.geometry()) # Use the spatial index to find points within the polygon ids = index.intersects(polygon_feature.geometry().boundingBox()) # Count the number of points that are actually within the polygon count = sum(polygon_feature.geometry().contains(point_layer.getFeature(id).geometry()) for id in ids) # Set the count field of the result feature result_feature[\"COUNT\"] = count # Add the result feature to the result layer result_layer.addFeature(result_feature) # Commit the changes to the result layer result_layer.commitChanges() # Add the result layer to the current project QgsProject.instance().addMapLayer(result_layer) Example execution: Figure 4: Aggregated data over Administrative Division Level 1. Step: 12 Prompt: Create a script to extract values from the \"50N_010W\" layer, which is already loaded in the workspace. For each point in the \"bats_data\" layer (also loaded in the workspace), retrieve the corresponding value from \"50N_010W\" based on its coordinates and store it in a new field named \"landcover\". Expected output: A script to extract landcover values for each feature in the \"bats_data\" layer. Example output: # Import necessary modules from qgis.core import QgsProject, QgsFeatureRequest # Get the layers project = QgsProject.instance() raster_layer = project.mapLayersByName('50N_010W')[0] vector_layer = project.mapLayersByName('bats_data')[0] # Check if the 'landcover' field already exists in the vector layer # If not, create it if 'landcover' not in [field.name() for field in vector_layer.fields()]: vector_layer.dataProvider().addAttributes([QgsField('landcover', QVariant.Double)]) vector_layer.updateFields() # Get the index of the 'landcover' field field_index = vector_layer.fields().indexFromName('landcover') # Start editing the vector layer vector_layer.startEditing() # For each feature (point) in the vector layer for feature in vector_layer.getFeatures(): # Get the point's coordinates point = feature.geometry().asPoint() # Get the corresponding value from the raster layer value = raster_layer.dataProvider().sample(point, 1)[0] # Update the 'landcover' field with the value feature.setAttribute(field_index, value) vector_layer.updateFeature(feature) # Commit the changes vector_layer.commitChanges() Example execution: Figure 5: Land cover values for records in the \"bats_data\" layer. References [O\u2019Mara et al., 2021] O'Mara MT, Amorim F, Scacco M, McCracken GF, Safi K, Mata V, Tome\u0301 R, Swartz S, Wikelski M, Beja P, Rebelo H, Dechmann DKN. 2021. Bats use topography and nocturnal updrafts to fly high and fast. Curr Biol. https://doi.org/10.1016/j.cub.2020.12.042","title":"Tutorials"},{"location":"tutorials/#tutorials","text":"QGIS User Conference 2025 This tutorial was prepared as part of the workshop \"AI-powered model building in QGIS,\" held at the QGIS UC25 . Requirements for this tutorial: QGIS >= 3.0.0 IntelliGeo plugin >= 0.1.0 Sample project","title":"Tutorials"},{"location":"tutorials/#about-the-data","text":"The sample project includes data from two data sources: Movebank and GADM . The GPS tracking data of European Freetailed bats (Tadarida teniotis) was produced by [O\u2019Mara et al., 2021], and is available under a Creative Commons license on the website Movebank . The data layer with administrative units (level 1) for Portugal and Spain was prepared using data available under a Creative Commons license at GADM .","title":"About the data"},{"location":"tutorials/#plugin-installation","text":"For detailed installation instructions, please refer to installation.md .","title":"Plugin installation"},{"location":"tutorials/#creating-a-new-conversation","text":"Figure 1 illustrates the process to create a new conversation: Click on the new conversation icon Provide a name Provide a description Select the LLM to use as back-end Provide a valid API Key for the LLM Figure 1: Creating a new conversation.","title":"Creating a new conversation"},{"location":"tutorials/#requesting-general-information","text":"In this section, you will interact with IntelliGeo to request general information about QGIS , the plugin, and the data available at your working space. You are encouraged to experiment with the provided prompts.","title":"Requesting general information"},{"location":"tutorials/#step-1","text":"Prompt: What is QGIS? Expected output: Description of the QGIS software. Example output: QGIS (Quantum GIS) is a free and open-source Geographic Information System (GIS) that allows you to create, edit, visualize, analyze and publish geospatial information. It supports various formats and functionalities, including vector, raster, and database formats. QGIS is widely used for spatial analysis, data management, and map production. It also supports plugins to enhance its functionality and can be customized using the PyQGIS Python API.","title":"Step: 1"},{"location":"tutorials/#step-2","text":"Prompt: What is a QGIS plugin? Expected output: Description of a plugin for QGIS. Example output: A QGIS plugin is a piece of software that adds new functionality or extends the capabilities of the QGIS application. Plugins can be developed by anyone using the Python programming language and the QGIS API (Application Programming Interface). They can be used for a variety of tasks, such as automating common tasks, customizing the user interface, performing complex spatial analyses, connecting to external databases, and much more. QGIS has a built-in Plugin Manager that allows users to install, update, and manage plugins directly within the application.","title":"Step: 2"},{"location":"tutorials/#step-3","text":"Prompt: Where can I get information about QGIS plugins? Expected output: Information about QGIS Plugin Repository. Example output: You can find information about QGIS plugins in several places: QGIS Plugin Repository : This is the official repository where all approved QGIS plugins are listed. You can access it directly from your QGIS software by going to Plugins > Manage and Install Plugins. Here, you can search for plugins, read their descriptions, and install them. QGIS Documentation : The official QGIS documentation provides information about core plugins and how to use them. You can access it at https://docs.qgis.org . Plugin Documentation : Most plugins come with their own documentation that provides detailed information about their functionality and usage. This documentation is usually accessible from the plugin's page in the QGIS Plugin Repository. QGIS Community : The QGIS community is a great resource for information about plugins. You can ask questions and share experiences on the QGIS mailing list or on GIS Stack Exchange. Remember to always check the compatibility of the plugin with your QGIS version.","title":"Step: 3"},{"location":"tutorials/#step-4","text":"Prompt: Is IntelliGeo a QGIS plugin? Expected output: Confirmation that IntelliGeo is a QGIS plugin. Example output: Yes, IntelliGeo is a QGIS plugin designed to assist users with various GIS tasks within the QGIS environment. It provides guidance, troubleshooting advice, and support for creating processing workflows.","title":"Step: 4"},{"location":"tutorials/#step-5","text":"Prompt: What can I do with IntelliGeo? Expected output: A list of tasks that IntelliGeo can support. Example output: With IntelliGeo, you can: Get step-by-step instructions for various GIS tasks in QGIS. Receive troubleshooting advice for common issues and errors. Get support in designing and executing project workflows. Learn about the latest updates on QGIS features and plugins. Generate processing workflows for the model designer by creating .model3 files. Get assistance in using PyQGIS for scripting and automating GIS tasks. Retrieve detailed information about your current QGIS project environment, including layer details and attributes. Remember, IntelliGeo is designed to provide concise, straightforward, and actionable information to help you efficiently use QGIS for your spatial analysis and GIS project needs.","title":"Step: 5"},{"location":"tutorials/#processing-with-a-single-data-layer","text":"In this section, you will generate scripts to process a single data layer.","title":"Processing with a single data layer"},{"location":"tutorials/#step-6","text":"Prompt: Create a script to calculate the number of data points for each bat in the layer \"bats_data,\" which is already loaded in the workspace. Expected output: Script to calculate the number of points for each bat. Example output: Sure, here is a PyQGIS script that calculates the number of data points for each bat in the \"bats_data\" layer. # Import necessary modules from qgis.core import QgsProject # Get the project instance project = QgsProject.instance() # Get the \"bats_data\" layer layer = project.mapLayersByName('bats_data')[0] # Check if the layer is valid if not layer.isValid(): print(\"Layer failed to load!\") else: # Create a dictionary to store the count of data points for each bat bat_counts = {} # Iterate over each feature (data point) in the layer for feature in layer.getFeatures(): # Get the bat id from the feature's attributes bat_id = feature['bat_id'] # If the bat id is already in the dictionary, increment the count if bat_id in bat_counts: bat_counts[bat_id] += 1 # If the bat id is not in the dictionary, add it with a count of 1 else: bat_counts[bat_id] = 1 # Print the count of data points for each bat for bat, count in bat_counts.items(): print(f\"Bat {bat} has {count} data points.\") This script first gets the \"bats_data\" layer from the current QGIS project. It then iterates over each feature (data point) in the layer, getting the bat ID from the feature's attributes. The script keeps a count of the number of data points for each bat in a dictionary. Finally, it prints out the count of data points for each bat. Example execution: Bat Bat4_3D6001852B980 has 1466 data points. Bat Bat5_3D6001852B98C has 1397 data points. Bat Bat1_3D6001852B958 has 1265 data points. Bat Bat6_3D6001852B98E has 1435 data points. Bat Bat3_3D6001852B978 has 1568 data points. Bat Bat2_3D6001852B95D has 219 data points. Bat Bat8_3D6001852B9A7 has 900 data points. Bat Bat7_3D6001852B9A3 has 1623 data points.","title":"Step: 6"},{"location":"tutorials/#step-7","text":"Prompt: Create a script that calculates basic statistics for the \"height\" attribute in the \"bats_data\" layer, which is already loaded in the workspace. The script should compute the following statistics: total number of points, minimum height, maximum height, average (mean) height, standard deviation of height. Expected output: Script to calculate basic statistics for the field \"height.\" Example output: # Import the required module from qgis.core import QgsVectorLayer, QgsFeatureRequest # Get the layer layer = QgsProject.instance().mapLayersByName('bats_data')[0] # Check if the layer is valid if not layer.isValid(): print(\"Layer failed to load!\") else: # Get the index of the 'height' field field_index = layer.fields().indexFromName('height') # Initialize variables to store statistics total_points = 0 min_height = float('inf') max_height = float('-inf') sum_height = 0 sum_squared_height = 0 # Iterate over each feature in the layer for feature in layer.getFeatures(): # Get the height value height = feature.attributes()[field_index] # Update statistics total_points += 1 min_height = min(min_height, height) max_height = max(max_height, height) sum_height += height sum_squared_height += height**2 # Calculate mean and standard deviation mean_height = sum_height / total_points std_dev_height = (sum_squared_height / total_points - mean_height**2)**0.5 # Print the statistics print(f\"Total number of points: {total_points}\") print(f\"Minimum height: {min_height}\") print(f\"Maximum height: {max_height}\") print(f\"Average (mean) height: {mean_height}\") print(f\"Standard deviation of height: {std_dev_height}\") Example execution: Total number of points: 9873 Minimum height: 4.0 Maximum height: 3150.0 Average (mean) height: 650.0176238225463 Standard deviation of height: 252.26758042089847","title":"Step: 7"},{"location":"tutorials/#step-8","text":"Prompt: Modify the latest produced script to calculate the statistics for each individual bat, using the \"bat_id\" field. Expected output: Script to calculate basic statistics per individual for the field \"height.\" Example output: # Import the required module from qgis.core import QgsVectorLayer, QgsFeatureRequest from collections import defaultdict # Get the layer layer = QgsProject.instance().mapLayersByName('bats_data')[0] # Check if the layer is valid if not layer.isValid(): print(\"Layer failed to load!\") else: # Get the index of the 'height' and 'bat_id' fields height_index = layer.fields().indexFromName('height') bat_id_index = layer.fields().indexFromName('bat_id') # Initialize a dictionary to store statistics for each bat bat_stats = defaultdict(lambda: {'total_points': 0, 'min_height': float('inf'), 'max_height': float('-inf'), 'sum_height': 0, 'sum_squared_height': 0}) # Iterate over each feature in the layer for feature in layer.getFeatures(): # Get the height and bat_id values height = feature.attributes()[height_index] bat_id = feature.attributes()[bat_id_index] # Update statistics for the current bat bat_stats[bat_id]['total_points'] += 1 bat_stats[bat_id]['min_height'] = min(bat_stats[bat_id]['min_height'], height) bat_stats[bat_id]['max_height'] = max(bat_stats[bat_id]['max_height'], height) bat_stats[bat_id]['sum_height'] += height bat_stats[bat_id]['sum_squared_height'] += height**2 # Calculate mean and standard deviation for each bat and print the statistics for bat_id, stats in bat_stats.items(): mean_height = stats['sum_height'] / stats['total_points'] std_dev_height = (stats['sum_squared_height'] / stats['total_points'] - mean_height**2)**0.5 print(f\"Bat ID: {bat_id}\") print(f\"Total number of points: {stats['total_points']}\") print(f\"Minimum height: {stats['min_height']}\") print(f\"Maximum height: {stats['max_height']}\") print(f\"Average (mean) height: {mean_height}\") print(f\"Standard deviation of height: {std_dev_height}\") print() Example execution: Bat ID: Bat4_3D6001852B980 Total number of points: 1466 Minimum height: 6.0 Maximum height: 1658.0 Average (mean) height: 721.6589358799454 Standard deviation of height: 275.40828363177724 Bat ID: Bat5_3D6001852B98C Total number of points: 1397 Minimum height: 166.0 Maximum height: 2704.0 Average (mean) height: 755.6406585540444 Standard deviation of height: 246.34593936186914 Bat ID: Bat1_3D6001852B958 Total number of points: 1265 Minimum height: 26.0 Maximum height: 3150.0 Average (mean) height: 668.7446640316206 Standard deviation of height: 279.81218789617225 Bat ID: Bat6_3D6001852B98E Total number of points: 1435 Minimum height: 4.0 Maximum height: 1228.0 Average (mean) height: 543.7602787456447 Standard deviation of height: 248.23846792712698 Bat ID: Bat3_3D6001852B978 Total number of points: 1568 Minimum height: 22.0 Maximum height: 2266.0 Average (mean) height: 673.4489795918367 Standard deviation of height: 270.03197552342056 Bat ID: Bat2_3D6001852B95D Total number of points: 219 Minimum height: 22.0 Maximum height: 1550.0 Average (mean) height: 616.3013698630137 Standard deviation of height: 198.86940839731218 Bat ID: Bat8_3D6001852B9A7 Total number of points: 900 Minimum height: 256.0 Maximum height: 1146.0 Average (mean) height: 604.9911111111111 Standard deviation of height: 106.70613815984397 Bat ID: Bat7_3D6001852B9A3 Total number of points: 1623 Minimum height: 70.0 Maximum height: 968.0 Average (mean) height: 580.6247689463955 Standard deviation of height: 194.04819050116532","title":"Step: 8"},{"location":"tutorials/#step-9","text":"Prompt: Create a script to generate a line vector layer from the existing \"bats_data\" layer, which is already loaded in the workspace. The script should create one line per bat, using the \"bat_id\" field to group individual bats. Ensure that the points for each bat are ordered chronologically based on the \"timestamp\" field before constructing the lines. Expected output: A script that groups the records per bat and creates line features from these groups. Example output: # Import necessary modules from qgis.PyQt.QtCore import QVariant from qgis.core import (QgsFeature, QgsField, QgsGeometry, QgsPoint, QgsVectorLayer, QgsProject) # Get the bats_data layer layer = QgsProject.instance().mapLayersByName('bats_data')[0] # Create a new memory layer for the lines line_layer = QgsVectorLayer('LineString', 'bat_paths', 'memory') # Add the necessary fields to the new layer pr = line_layer.dataProvider() pr.addAttributes([QgsField('bat_id', QVariant.String)]) line_layer.updateFields() # Create a dictionary to store the points for each bat bat_points = {} # Iterate over the features in the bats_data layer for feature in layer.getFeatures(): # Get the bat_id and timestamp for the current feature bat_id = feature['bat_id'] timestamp = feature['timestamp'] # Get the geometry of the current feature and convert it to a point geom = feature.geometry() point = QgsPoint(geom.asPoint()) # If the bat_id is not already in the dictionary, add it with the point and timestamp if bat_id not in bat_points: bat_points[bat_id] = [(timestamp, point)] # If the bat_id is already in the dictionary, append the point and timestamp to the list else: bat_points[bat_id].append((timestamp, point)) # Iterate over the bats in the dictionary for bat_id, points in bat_points.items(): # Sort the points by timestamp points.sort() # Create a new feature for the line layer feat = QgsFeature() # Set the bat_id field to the current bat_id feat.setAttributes([bat_id]) # Create a line geometry from the sorted points and set it for the feature line = QgsGeometry.fromPolyline([point for timestamp, point in points]) feat.setGeometry(line) # Add the feature to the line layer pr.addFeature(feat) # Update the extents of the line layer line_layer.updateExtents() # Add the line layer to the map QgsProject.instance().addMapLayer(line_layer) Example execution: Figure 2: Individual bats trajectories.","title":"Step: 9"},{"location":"tutorials/#step-10","text":"Prompt: Create a script that generates a vector layer representing a regular grid of 0.05 degrees \u00d7 0.05 degrees cells covering the full extent of the \"bats_data\" layer, which is already loaded in the workspace. Then, aggregate the data from \"bats_data\" by counting the number of points that fall within each grid cell. Expected output: A script that produces a grid and aggregates the records from the \"bats_data\" layer. Example output: # Import necessary modules from qgis.core import QgsVectorLayer, QgsProcessing, QgsProcessingFeatureSourceDefinition from qgis.analysis import QgsNativeAlgorithms import processing # Initialize QGIS's processing framework QgsApplication.processingRegistry().addProvider(QgsNativeAlgorithms()) # Get the \"bats_data\" layer bats_data_layer = QgsProject.instance().mapLayersByName('bats_data')[0] # Define the grid size grid_size = 0.05 # Define the parameters for the \"Create grid\" algorithm grid_parameters = { 'TYPE': 2, # Rectangle (polygon) 'EXTENT': bats_data_layer.extent(), # Use the extent of the \"bats_data\" layer 'HSPACING': grid_size, # Horizontal spacing 'VSPACING': grid_size, # Vertical spacing 'CRS': bats_data_layer.crs(), # Coordinate reference system 'OUTPUT': 'memory:' # Output to memory } # Run the \"Create grid\" algorithm grid_result = processing.run('native:creategrid', grid_parameters) # Get the resulting grid layer grid_layer = grid_result['OUTPUT'] # Define the parameters for the \"Count points in polygon\" algorithm count_parameters = { 'POLYGONS': grid_layer, # Use the grid layer as the polygon layer 'POINTS': QgsProcessingFeatureSourceDefinition(bats_data_layer.id()), # Use the \"bats_data\" layer as the point layer 'OUTPUT': 'memory:' # Output to memory } # Run the \"Count points in polygon\" algorithm count_result = processing.run('native:countpointsinpolygon', count_parameters) # Get the resulting layer result_layer = count_result['OUTPUT'] # Add the resulting layer to the map QgsProject.instance().addMapLayer(result_layer) Example execution: Figure 3: Aggregated data over a grid.","title":"Step: 10"},{"location":"tutorials/#processing-with-two-data-layers","text":"","title":"Processing with two data layers"},{"location":"tutorials/#step-11","text":"Prompt: Create a script to count the number of points from the \"bats_data\" layer that fall within each polygon of the \"Iberian_Peninsula_Level_1\" layer. Both layers are already loaded in the workspace. The script must produce a new in-memory vector layer containing the polygons from \"Iberian_Peninsula_Level_1\", with a field named \"COUNT\" that indicates the number of points contained within each polygon. Expected output: Script to calculate the number of records within each administrative division (level 1). Example output: # Import necessary modules from qgis.core import * # Define the names of the input layers point_layer_name = \"bats_data\" polygon_layer_name = \"Iberian_Peninsula_Level_1\" # Retrieve the layers from the current project point_layer = QgsProject.instance().mapLayersByName(point_layer_name)[0] polygon_layer = QgsProject.instance().mapLayersByName(polygon_layer_name)[0] # Create a new in-memory vector layer to store the results result_layer = QgsVectorLayer(\"Polygon?crs=epsg:4326\", \"result\", \"memory\") # Start editing the result layer result_layer.startEditing() # Add a new field to the result layer to store the count of points result_layer.dataProvider().addAttributes([QgsField(\"COUNT\", QVariant.Int)]) result_layer.updateFields() # Create a spatial index for the point layer to speed up the spatial query index = QgsSpatialIndex(point_layer.getFeatures()) # Iterate over each feature (i.e., polygon) in the polygon layer for polygon_feature in polygon_layer.getFeatures(): # Create a new feature for the result layer result_feature = QgsFeature(result_layer.fields()) # Copy the geometry from the polygon feature result_feature.setGeometry(polygon_feature.geometry()) # Use the spatial index to find points within the polygon ids = index.intersects(polygon_feature.geometry().boundingBox()) # Count the number of points that are actually within the polygon count = sum(polygon_feature.geometry().contains(point_layer.getFeature(id).geometry()) for id in ids) # Set the count field of the result feature result_feature[\"COUNT\"] = count # Add the result feature to the result layer result_layer.addFeature(result_feature) # Commit the changes to the result layer result_layer.commitChanges() # Add the result layer to the current project QgsProject.instance().addMapLayer(result_layer) Example execution: Figure 4: Aggregated data over Administrative Division Level 1.","title":"Step: 11"},{"location":"tutorials/#step-12","text":"Prompt: Create a script to extract values from the \"50N_010W\" layer, which is already loaded in the workspace. For each point in the \"bats_data\" layer (also loaded in the workspace), retrieve the corresponding value from \"50N_010W\" based on its coordinates and store it in a new field named \"landcover\". Expected output: A script to extract landcover values for each feature in the \"bats_data\" layer. Example output: # Import necessary modules from qgis.core import QgsProject, QgsFeatureRequest # Get the layers project = QgsProject.instance() raster_layer = project.mapLayersByName('50N_010W')[0] vector_layer = project.mapLayersByName('bats_data')[0] # Check if the 'landcover' field already exists in the vector layer # If not, create it if 'landcover' not in [field.name() for field in vector_layer.fields()]: vector_layer.dataProvider().addAttributes([QgsField('landcover', QVariant.Double)]) vector_layer.updateFields() # Get the index of the 'landcover' field field_index = vector_layer.fields().indexFromName('landcover') # Start editing the vector layer vector_layer.startEditing() # For each feature (point) in the vector layer for feature in vector_layer.getFeatures(): # Get the point's coordinates point = feature.geometry().asPoint() # Get the corresponding value from the raster layer value = raster_layer.dataProvider().sample(point, 1)[0] # Update the 'landcover' field with the value feature.setAttribute(field_index, value) vector_layer.updateFeature(feature) # Commit the changes vector_layer.commitChanges() Example execution: Figure 5: Land cover values for records in the \"bats_data\" layer.","title":"Step: 12"},{"location":"tutorials/#references","text":"[O\u2019Mara et al., 2021] O'Mara MT, Amorim F, Scacco M, McCracken GF, Safi K, Mata V, Tome\u0301 R, Swartz S, Wikelski M, Beja P, Rebelo H, Dechmann DKN. 2021. Bats use topography and nocturnal updrafts to fly high and fast. Curr Biol. https://doi.org/10.1016/j.cub.2020.12.042","title":"References"},{"location":"use/","text":"IntelliGeo Quick Start Welcome to the IntelliGeo Quick Start Guide ! This guide provides a range of examples and common use cases to help you effectively utilize the IntelliGeo plugin for geospatial tasks in QGIS. Whether you're a beginner or an advanced user, this document offers clear and concise examples to get you started and deepen your knowledge. Getting Started Before exploring the examples, ensure the following prerequisites are met: QGIS Installed : Download and install the latest version of QGIS from QGIS.org . Plugin Installation : Install IntelliGeo from the QGIS Plugin Repository or a custom source. API Key Ready : Ensure you have an active API key for OpenAI or Cohere. Sample Data : Some examples use preloaded sample datasets. For a detailed guide on installation and obtaining API keys, visit the Installation and API Keys page . Once IntelliGeo is installed, the plugin's toolbar or menu should appear in your QGIS interface. You\u2019re now ready to dive into the examples! Quick Start Video Watch our Quick Start Video . Example Use Cases Use Case 1: Generating Attribute Lists from a Vector Layer Generate a model to list the attributes from a vector layer in the workspace by selecting the layer by name. Prompt : Generate a model to list the attributes from a vector layer in the workspace. Select the layer by name. Note : Replace the placeholder with your layer's name. Use Case 2: Producing Attribute Descriptions for a Vector Layer Generate a model that produces attribute descriptions for a vector layer, including attribute names, data types, counts of NULL values, and unique values. Prompt : Generate a model to describe the attributes of a vector layer. Include names, data types, NULL value counts, and unique value counts. Select the layer by name. Note : Replace the placeholder with your layer's name. Use Case 3: Producing Statistics for Polygon Areas Generate a model that calculates area statistics for polygons in a loaded layer. The output includes minimum, maximum, average, standard deviation, and total feature count. Prompt : Produce area statistics for polygons in the selected layer, including minimum, maximum, mean, standard deviation, and total features. Note : Replace the placeholder with your layer's name. Advanced Examples Use Case 1: Calculating Buffers Around Features Generate a buffer area of 5000 meters with 40 segments around features in a vector layer. Prompt : Create a buffer area of 5000 meters and 40 segments around features in the selected layer. Note : Replace the placeholder with your layer's name. Use Case 2: Generating Random Points Create a model that generates 1000 random points over the current map extent in EPSG:28992. Prompt : Generate 1000 random points over the current map extent using EPSG:28992. Use Case 3: Generating Random Lines Create a model that generates 1000 random lines, each 5000 meters long, over the current map extent in EPSG:28992. Prompt : Generate 1000 random lines, each 5000 meters long, using EPSG:28992. Troubleshooting and Tips A common issue when using the plugin is \"hallucinated imports,\" where scripts reference non-existent imports or modules in your QGIS or Python environment. To avoid this: Verify all imported modules exist in your Python installation. Ensure compatibility with the QGIS environment by testing custom scripts thoroughly.","title":"How to use"},{"location":"use/#intelligeo-quick-start","text":"Welcome to the IntelliGeo Quick Start Guide ! This guide provides a range of examples and common use cases to help you effectively utilize the IntelliGeo plugin for geospatial tasks in QGIS. Whether you're a beginner or an advanced user, this document offers clear and concise examples to get you started and deepen your knowledge.","title":"IntelliGeo Quick Start"},{"location":"use/#getting-started","text":"Before exploring the examples, ensure the following prerequisites are met: QGIS Installed : Download and install the latest version of QGIS from QGIS.org . Plugin Installation : Install IntelliGeo from the QGIS Plugin Repository or a custom source. API Key Ready : Ensure you have an active API key for OpenAI or Cohere. Sample Data : Some examples use preloaded sample datasets. For a detailed guide on installation and obtaining API keys, visit the Installation and API Keys page . Once IntelliGeo is installed, the plugin's toolbar or menu should appear in your QGIS interface. You\u2019re now ready to dive into the examples!","title":"Getting Started"},{"location":"use/#quick-start-video","text":"Watch our Quick Start Video .","title":"Quick Start Video"},{"location":"use/#example-use-cases","text":"","title":"Example Use Cases"},{"location":"use/#use-case-1-generating-attribute-lists-from-a-vector-layer","text":"Generate a model to list the attributes from a vector layer in the workspace by selecting the layer by name. Prompt : Generate a model to list the attributes from a vector layer in the workspace. Select the layer by name. Note : Replace the placeholder with your layer's name.","title":"Use Case 1: Generating Attribute Lists from a Vector Layer"},{"location":"use/#use-case-2-producing-attribute-descriptions-for-a-vector-layer","text":"Generate a model that produces attribute descriptions for a vector layer, including attribute names, data types, counts of NULL values, and unique values. Prompt : Generate a model to describe the attributes of a vector layer. Include names, data types, NULL value counts, and unique value counts. Select the layer by name. Note : Replace the placeholder with your layer's name.","title":"Use Case 2: Producing Attribute Descriptions for a Vector Layer"},{"location":"use/#use-case-3-producing-statistics-for-polygon-areas","text":"Generate a model that calculates area statistics for polygons in a loaded layer. The output includes minimum, maximum, average, standard deviation, and total feature count. Prompt : Produce area statistics for polygons in the selected layer, including minimum, maximum, mean, standard deviation, and total features. Note : Replace the placeholder with your layer's name.","title":"Use Case 3: Producing Statistics for Polygon Areas"},{"location":"use/#advanced-examples","text":"","title":"Advanced Examples"},{"location":"use/#use-case-1-calculating-buffers-around-features","text":"Generate a buffer area of 5000 meters with 40 segments around features in a vector layer. Prompt : Create a buffer area of 5000 meters and 40 segments around features in the selected layer. Note : Replace the placeholder with your layer's name.","title":"Use Case 1: Calculating Buffers Around Features"},{"location":"use/#use-case-2-generating-random-points","text":"Create a model that generates 1000 random points over the current map extent in EPSG:28992. Prompt : Generate 1000 random points over the current map extent using EPSG:28992.","title":"Use Case 2: Generating Random Points"},{"location":"use/#use-case-3-generating-random-lines","text":"Create a model that generates 1000 random lines, each 5000 meters long, over the current map extent in EPSG:28992. Prompt : Generate 1000 random lines, each 5000 meters long, using EPSG:28992.","title":"Use Case 3: Generating Random Lines"},{"location":"use/#troubleshooting-and-tips","text":"A common issue when using the plugin is \"hallucinated imports,\" where scripts reference non-existent imports or modules in your QGIS or Python environment. To avoid this: Verify all imported modules exist in your Python installation. Ensure compatibility with the QGIS environment by testing custom scripts thoroughly.","title":"Troubleshooting and Tips"}]}